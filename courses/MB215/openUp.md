![slide0](slidestart://?class="step+slide"+data-x="-1000"+data-y="-2200")

<img src="https://rhildred.github.io/courses/MB215/sdlc.svg" title="System Development Lifecycle" alt="System Development Lifecycle" style="height:500px;display:block;margin:0 auto 1em" />

#System Development Lifecycle/ Open Unified Process

Rich Hildred - rhildred@wlu.ca - 519-594-0900

![notes](slidenotestart://)

How can we work together as a team? Excellent question! The Open Unified Process is one way for teams, possibly spanning a whole organization, to work together on software.

![/notes](slidenoteend://)

![/slide0](slideend:://)

![slide.5](slidestart://?class="step+slide"+data-x="-1000"+data-y="-1500")

#A hurdle rate is the "line in the sand" that helps companies decide whether to pursue projects.

<img src="https://rhildred.github.io/courses/MB215/hurdles.svg" title="Hurdle Rate" alt="hurdle rate" style="height:500px;display:block;margin:0 auto 1em" />


![notes](slidenotestart://)

Traditionally software is a no brainer for creating shareholder value. Except projects fail sometimes (often actually) and destroy shareholder value. Software methods are an attempt to reduce the probability of failure.

![/notes](slidenoteend://)

![/slide.5](slideend:://)

![slide1](slidestart://?class="step+slide"+data-x="-1000"+data-y="-800")

#We covered the Systems Development Life Cycle in MB115

<img src="https://rhildred.github.io/courses/MB215/sdlc.svg" title="System Development Lifecycle" alt="System Development Lifecycle" style="height:500px;display:block;margin:1em auto" />

![notes](slidenotestart://)

###From Williams and Sawyer

Systems analysis and design is a
six-phase problem-solving procedure
for examining an information
system and improving it. 

* The six phases make up what is called
the systems development life cycle.

* The systems development life
cycle (SDLC) is the step-by-step
process that many organizations
follow during systems analysis
and design.

![/notes](slidenoteend://)

![/slide1](slideend:://)

![slide2](slidestart://?class="step+slide"+data-x="-1000"+data-y="-100")

#Preliminary Investigation

<img src="https://rhildred.github.io/courses/MB215/sdlcStep1.svg" title="System Development Lifecycle" alt="System Development Lifecycle" style="height:500px;display:block;margin:1em auto" />

![notes](slidenotestart://)

1. Conduct preliminary analysis. This
includes stating the objectives,
defining the nature and scope of
the problem.
2. Propose alternative solutions:
leave system alone, make it more
efficient, or build a new system.
3. Describe costs and benefits of
each solution.
4. Submit a preliminary plan with
recommendations.

![/notes](slidenoteend://)

![/slide2](slideend:://)

![slide3](slidestart://?class="step+slide"+data-x="-1000"+data-y="600")

#Systems Analysis

<img src="https://rhildred.github.io/courses/MB215/sdlcStep2.svg" title="System Development Lifecycle" alt="System Development Lifecycle" style="height:500px;display:block;margin:1em auto" />

![notes](slidenotestart://)

1. Gather data, using tools of
 written documents, inter-
 views, questionnaires, and
 observations.
2. Analyze the data, using
 modeling tools: grid charts,
 decision tables, data flow
 diagrams, systems flow-
 charts, connectivity
 diagrams.
3. Write a report.

![/notes](slidenoteend://)

![/slide3](slideend:://)

![slide4](slidestart://?class="step+slide"+data-x="-1000"+data-y="1300")

#Systems Design

<img src="https://rhildred.github.io/courses/MB215/sdlcStep3.svg" title="System Development Lifecycle" alt="System Development Lifecycle" style="height:500px;display:block;margin:1em auto" />

![notes](slidenotestart://)

1. Do a preliminary design, using
 CASE tools, prototyping tools,
 and project management software, among others.
2. Do a detail design, defining
 requirements for output, input,
 storage, and processing and
 system controls and backup.
3. Write a report.

![/notes](slidenoteend://)

![/slide4](slideend:://)

![slide5](slidestart://?class="step+slide"+data-x="-1000"+data-y="2000")

#Systems Development

<img src="https://rhildred.github.io/courses/MB215/sdlcStep4.svg" title="System Development Lifecycle" alt="System Development Lifecycle" style="height:500px;display:block;margin:1em auto" />

![notes](slidenotestart://)

1. Develop or acquire the development
 software.
2. Acquire the hardware.
3. Test the system.

![/notes](slidenoteend://)

![/slide5](slideend:://)

![slide6](slidestart://?class="step+slide"+data-x="-1000"+data-y="2700")

#Systems Implementation

<img src="https://rhildred.github.io/courses/MB215/sdlcStep5.svg" title="System Development Lifecycle" alt="System Development Lifecycle" style="height:500px;display:block;margin:1em auto" />

![notes](slidenotestart://)

1. Convert hardware, software,
 and files through one of four
 types of conversions: direct,
 parallel, phased, or pilot.
    * Direct implementation: This means that the user simply stops using the
    old system and starts using the new one. The risk of this method should be
    evident: What if the new system doesn’t work? If the old system has truly
    been discontinued, there is nothing to fall back on.
    * Parallel implementation: This means that the old and new systems are
    operated side by side until the new system has shown it is reliable, at which
    time the old system is discontinued. Obviously there are benefits in taking
    this cautious approach. If the new system fails, the organization can switch
    back to the old one. The difficulty with this method is the expense of paying
    for the equipment and people to keep two systems going at the same time.
    * Phased implementation: This means that parts of the new system are
    phased in separately ... either at different times (parallel) or all at once in
    groups (direct).
    * Pilot implementation: This means that the entire system is tried out,
    but only by some users. Once the reliability has been proved, the system can be introduced to more users until it is progressively "rolled out" to the entire population.
2. Train the users.

![/notes](slidenoteend://)

![/slide6](slideend:://)

![slide7](slidestart://?class="step+slide"+data-x="-1000"+data-y="3400")

#Systems Maintenance

<img src="https://rhildred.github.io/courses/MB215/sdlcStep6.svg" title="System Development Lifecycle" alt="System Development Lifecycle" style="height:500px;display:block;margin:1em auto" />

![notes](slidenotestart://)

**Phase 6**, systems maintenance, adjusts and improves the system by having
system audits and periodic evaluations and by making changes based on
new conditions. Even with the conversion accomplished
and the users trained, the system won't just run itself. There is a sixth and
continuous phase in which the information system must be monitored to
ensure that it is successful. Maintenance includes not only keeping the machinery
running but also updating and upgrading the system to keep pace with new
products, services, customers, government regulations, and other requirements.
After some time, maintenance costs will accelerate as attempts continue to
keep the system responsive to user needs. 

At some point, these maintenance costs become excessive, indicating that it may be time to start the entire SDLC
again.

![/notes](slidenoteend://)

![/slide7](slideend:://)

![slide8](slidestart://?class="step+slide"+data-x="-1000"+data-y="4100")

#Waterfall Method

<img src="https://rhildred.github.io/courses/MB215/Waterfall_model.svg" title="System Development Lifecycle" alt="System Development Lifecycle" style="height:500px;display:block;margin:1em auto" />

![notes](slidenotestart://)

The five steps in the waterfall programming process are as follows:

1. Clarify/define the problem ... include needed output, input, processing
requirements.
2. Design a solution ... use modeling tools to chart the program.
3. Code the program ... use a programming language’s syntax, or rules, to
write the program.
4. Test the program ... get rid of any logic errors, or "bugs," in the program
("debug" it).
5. Document and maintain the program include written instructions for
users, explanation of the program, and operating instructions. 

![/notes](slidenoteend://)

![/slide8](slideend:://)

![slide9](slidestart://?class="step+slide"+data-x="-1000"+data-y="4800")

#Clarify Problem

<img src="https://rhildred.github.io/courses/MB215/Waterfall_model1.svg" title="System Development Lifecycle" alt="System Development Lifecycle" style="height:500px;display:block;margin:1em auto" />

![notes](slidenotestart://)

1. Clarify objectives and users.
2. Clarify desired outputs.
3. Clarify desired inputs.
4. Clarify desired processing.
5. Double-check feasibility of
 implementing the program.
6. Document the analysis.

![/notes](slidenoteend://)

![/slide9](slideend:://)

![slide10](slidestart://?class="step+slide"+data-x="-1000"+data-y="5500")

#Design Solution

<img src="https://rhildred.github.io/courses/MB215/Waterfall_model2.svg" title="System Development Lifecycle" alt="System Development Lifecycle" style="height:500px;display:block;margin:1em auto" />

![notes](slidenotestart://)

1. Determine program logic through
top-down approach and modularization,
using a hierarchy chart.
2. Design details using pseudocode
and/or flowcharts, preferably
involving control structures.

![/notes](slidenoteend://)

![/slide10](slideend:://)

![slide10.5](slidestart://?class="step+slide"+data-x="-1000"+data-y="6200")

#Structured Design

<img src="https://rhildred.github.io/courses/MB115/shoeTieflowchart.svg" title="System Development Lifecycle" alt="System Development Lifecycle" style="height:500px;display:block;margin:1em auto" />

![notes](slidenotestart://)

When we used the Waterfall model at NCR, it was previous to object design, as we experienced with greenfoot.

![/notes](slidenoteend://)

![/slide10.5](slideend:://)

![slide11](slidestart://?class="step+slide"+data-x="-1000"+data-y="6900")

#Code Program

<img src="https://rhildred.github.io/courses/MB215/Waterfall_model3.svg" title="System Development Lifecycle" alt="System Development Lifecycle" style="height:500px;display:block;margin:1em auto" />

![notes](slidenotestart://)

The third step in programming
is to translate
the logic of the program
worked out from pseudocode
or flowcharts into a
high level programming
language, following its
grammatical rules.

1. Select the appropriate high level
programming language.
2. Code the program in that language,
following the syntax carefully.

![/notes](slidenoteend://)

![/slide11](slideend:://)

![slide12](slidestart://?class="step+slide"+data-x="-1000"+data-y="7600")

#Test Program

<img src="https://rhildred.github.io/courses/MB215/Waterfall_model4.svg" title="System Development Lifecycle" alt="System Development Lifecycle" style="height:500px;display:block;margin:1em auto" />

![notes](slidenotestart://)

1. **Perform Desk checking** Desk checking is simply reading through, or
checking, the program to make sure that it’s free of errors and that the
logic works. In other words, desk checking is like proofreading. This step
should be taken before the program is actually run on a computer.
2. **Debug the Program** Once the program has been desk-checked, further
errors, or “bugs,” will doubtless surface. To debug means to detect, locate,
and remove all errors in a computer program. Mistakes may be syntax
errors or logic errors. Syntax errors are caused by typographical errors
and incorrect use of the programming language. Logic errors are caused
by incorrect use of control structures. Programs called diagnostics exist
to check program syntax and display syntax error messages. Diagnostic programs
thus help identify and solve problems.
Sometimes debugging is partially done in the third step, program coding,
using the "buddy system." In this system, two people sit side by side; while one
person (the "driver") codes, the other person (the "navigator") checks the code,
corrects it, and offers suggestions for improvement. 2
3. **Run Real World Data** After desk-checking and debugging, the program
may run fine—in the laboratory. However, it needs to be tested with
real data; this is called beta testing. Indeed, it is even advisable to test the
program with bad data ... data that is faulty, incomplete, or in overwhelming
quantities ... to see if you can make the system crash. Many users, after all,
may be far careless than programmers
have anticipated. 

![/notes](slidenoteend://)

![/slide12](slideend:://)

![slide13](slidestart://?class="step+slide"+data-x="-1000"+data-y="8300")

#Document/ Maintain

<img src="https://rhildred.github.io/courses/MB215/Waterfall_model5.svg" title="System Development Lifecycle" alt="System Development Lifecycle" style="height:500px;display:block;margin:1em auto" />

![notes](slidenotestart://)

1. Write user documentation.
2. Write operator documentation.
3. Write programmer documentation.
4. Maintain the program.

![/notes](slidenoteend://)

![/slide13](slideend:://)

![slide14](slidestart://?class="step+slide"+data-x="-1000"+data-y="9000")

#(Open) Unified Process

<img src="https://upload.wikimedia.org/wikipedia/commons/2/2c/Openup-basic_lifecycle.jpg" alt="Unified processes have 4 phases" style="display:block;margin:1em auto"/>

![notes](slidenotestart://)

The open unified project comes from the influence of the agile manifesto (we will talk more about that Wednesday) and the Rational Unified Process

The Rational Unified Process recognizes that:

* Project failure is caused by a combination of several symptoms, though each project fails in a unique way. The outcome of their study was a system of software best practices they named the Rational Unified Process. 

* The Process was designed with the same techniques the team used to design software; it has an underlying object-oriented model, using Unified Modeling Language (UML). 

Unified Processes have 4 phases:

* Inception phase
* Elaboration phase
* Construction phase
* Transition phase

*From* http://www.utdallas.edu/~kcooper/6362/material/Related%20Standards/Not%20Architecture%20Specific/Process%20meta-models/difference-unified-processes.ppt retrieved Jan. 31, 2016

We call the unified processes stage gate models, as each phase has a gate before passing on to the next.

![/notes](slidenoteend://)

![/slide14](slideend:://)

![slide15](slidestart://?class="step+slide"+data-x="-1000"+data-y="9700")

#Object Domain Model

<img src="https://upload.wikimedia.org/wikipedia/commons/5/58/A2_4_Semantic_Data_Models.svg" alt="Semantic Data Models" style="display:block;margin:1em auto"/>

![notes](slidenotestart://)

Like in Greenfoot, we use objects to describe the system. The objects abstract things like rows and columns in databases into things that we are modeling in the real world.

![/notes](slidenoteend://)

![/slide15](slideend:://)

![slide16](slidestart://?class="step+slide"+data-x="-1000"+data-y="10400")

<img src="https://rhildred.github.io/courses/MB215/CDC_UP_Business_Needs_Statement_Checklist.svg" alt="Business needs" style="display:block;margin:0 auto;height:650px"/>

![notes](slidenotestart://)

Although each company generally defines the stagegate documents that they require, the Center for disease control in Atlanta defines some checklists and templates for the various phasegates. This particular one is for the inception phase.

![/notes](slidenoteend://)

![/slide16](slideend:://)

![slide17](slidestart://?class="step+slide"+data-x="-1000"+data-y="11100")

<img src="https://rhildred.github.io/courses/MB215/EPLC_Logical_Data_Model_Checklist.svg" alt="Logical Data Model" style="display:block;width:775px"/>

![notes](slidenotestart://)

An important reason for project failure and death marches is missed requirements. This checklist is aimed at determining if all of the business data requirements have been captured in the domain model.

![/notes](slidenoteend://)

![/slide17](slideend:://)

![slide18](slidestart://?class="step+slide"+data-x="-1000"+data-y="11800")

<img src="https://rhildred.github.io/courses/MB215/EPLC_SLA_MOU_Checklist.svg" alt="Service Level Agreement" style="display:block;margin:0 auto;height:650px"/>

![notes](slidenotestart://)

At the end of implementation, resources are often pirated for other projects. This stagegate document captures the plan for support in the transition phase.

![/notes](slidenoteend://)

![/slide18](slideend:://)

![slide19](slidestart://?class="step+slide"+data-x="-1000"+data-y="12500")

<img src="https://rhildred.github.io/courses/MB215/CDC_UP_Project_Close-Out_Checklist.svg" alt="project close out" style="display:block;margin:0 auto;height:650px"/>

![notes](slidenotestart://)

It's not over till all parties involved agree that it's over. This is an important checklist that I have used to bring closure to a project, more than once.

![/notes](slidenoteend://)

![/slide19](slideend:://)

![slide20](slidestart://?class="step+slide"+data-x="-1000"+data-y="13200")

#Most Companies Have Many Projects

<img src="https://rhildred.github.io/courses/MB215/BCG-Matrix.svg" alt="The BCG matrix is used for portfolio management" style="display:block;margin:1em auto;height:500px"/>

![notes](slidenotestart://)

A phasegate approach helps them to know which ones are in good shape. Even when we talk about Agile on Wednesday, the phasegate approach is still used at a management level.

![/notes](slidenoteend://)

![/slide20](slideend:://)
